package br.ufes.analisador.lexico.jflex;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;

// Terminal
terminal AUTO;
terminal STATIC;
terminal EXTERN;
terminal CONST;
terminal VOID;
terminal CHAR;
terminal FLOAT;
terminal DOUBLE;
terminal SIGNED;
terminal UNSIGNED;
terminal INT;
terminal SHORT;
terminal LONG;
terminal RETURN;
terminal PRINTF;
terminal SCANF;
terminal BREAK;
terminal IF;
terminal ELSE;
terminal LPAREN;
terminal RPAREN;
terminal LBRACE;
terminal RBRACE;
terminal LBRACK;
terminal RBRACK;
terminal SEMICOLON;
terminal COMMA;
terminal DOT;
terminal EQ;
terminal GT;
terminal LT;
terminal NOT;
terminal EQEQ;
terminal LTEQ;
terminal GTEQ;
terminal NOTEQ;
terminal AND;
terminal OR;
terminal PLUS;
terminal MINUS;
terminal MULT;
terminal DIV;
terminal MOD;
terminal PLUSEQ;
terminal MINUSEQ;
terminal MULTEQ;
terminal DIVEQ;
terminal MODEQ;
terminal DEFINE;
terminal ID;
terminal NUM_FLOAT;
terminal NUM_INT;
terminal CRLF;
terminal STRING;

// Não terminal
non terminal programa;
non terminal especificador;
non terminal tipo;
non terminal inteiro;
non terminal programa2;
non terminal listaID;
non terminal listaIDTail;
non terminal listaParametros;
non terminal listaParamRestante;
non terminal declaracaoParam;
non terminal declaracaoParam2;
non terminal declParamRestante;
non terminal bloco;
non terminal conjuntoInst;
non terminal instrucoes;
non terminal instrucoesIf;
non terminal expressao;
non terminal atribuicao;
non terminal operadorAtrib;
non terminal expr;
non terminal exprList;
non terminal exprListTail;
non terminal exprOr;
non terminal exprAnd;
non terminal exprAnd2;
non terminal exprEqual;
non terminal exprEqual2;
non terminal exprRelational;
non terminal exprRelational2;
non terminal exprPlus;
non terminal exprPlus2;
non terminal exprMult;
non terminal exprMult2;
non terminal exprUnary;
non terminal exprParenthesis;
non terminal primary;
non terminal primaryID;
non terminal num;
non terminal literal;

start with programa;

// Gramática
programa ::= especificador tipo ID programa2 | DEFINE ID num CRLF programa | ; verificar depois o ERRO
especificador ::= AUTO | STATIC | EXTERN | CONST | ;
tipo ::= VOID | CHAR | FLOAT | DOUBLE | SIGNED inteiro | UNSIGNED inteiro | inteiro;

inteiro ::= SHORT | INT | LONG;
programa2 ::= SEMICOLON programa | LBRACK num RBRACK SEMICOLON programa | LPAREN listaParametros RPAREN bloco programa | COMMA listaID programa;

listaID ::= ID declaracaoParam2 listaIDTail;
listaIDTail ::= SEMICOLON | COMMA listaID;
listaParametros ::= listaParamRestante | ;
listaParamRestante ::= declaracaoParam declParamRestante;
declaracaoParam ::= tipo ID declaracaoParam2;
declaracaoParam2 ::= LBRACK num RBRACK | ;
declParamRestante ::= COMMA listaParamRestante | ;
bloco ::= LBRACE conjuntoInst RBRACE | SEMICOLON conjuntoInst ;
conjuntoInst ::= programa conjuntoInst | instrucoes conjuntoInst | ;
instrucoes ::= ID expressao SEMICOLON | RETURN expr SEMICOLON | PRINTF LPAREN expr RPAREN SEMICOLON | SCANF LPAREN ID RPAREN SEMICOLON | BREAK SEMICOLON | IF LPAREN expr RPAREN instrucoes instrucoesIf;

instrucoesIf ::= ELSE instrucoes | ;
expressao ::= atribuicao | LBRACK expr RBRACK atribuicao | LPAREN exprList RPAREN | ;
atribuicao ::= operadorAtrib expr;
operadorAtrib ::= EQ | MULTEQ | DIVEQ | MODEQ | PLUSEQ | MINUSEQ;
expr ::= exprAnd exprOr;
exprList ::= expr exprListTail | ;
exprListTail ::= COMMA exprList | ;
exprOr ::= OR exprAnd exprOr | ;
exprAnd ::= exprEqual exprAnd2;
exprAnd2 ::= AND exprEqual exprAnd2 | ;
exprEqual ::= exprRelational exprEqual2;
exprEqual2 ::= EQEQ exprRelational exprEqual2 | NOTEQ exprRelational exprEqual2 | ;
exprRelational ::= exprPlus exprRelational2;
exprRelational2 ::= LT exprPlus exprRelational2 | LTEQ exprPlus exprRelational2 | GT exprPlus exprRelational2 | GTEQ exprPlus exprRelational2 | ;

exprPlus ::= exprMult exprPlus2;
exprPlus2 ::= PLUS exprMult exprPlus2 | MINUS exprMult exprPlus2 | ;
exprMult ::= exprUnary exprMult2;
exprMult2 ::= MULT exprUnary exprMult2 | DIV exprUnary exprMult2 | ;
exprUnary ::= PLUS exprParenthesis | MINUS exprParenthesis | exprParenthesis;
exprParenthesis ::= LPAREN expr RPAREN | primary;
primary ::= ID primaryID | num | literal;
primaryID ::= LBRACK primary RBRACK | LPAREN exprList RPAREN | ;

literal ::= STRING | CHAR;
num ::= NUM_INT | NUM_FLOAT;